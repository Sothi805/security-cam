<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CCTV Monitoring Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #0f1419;
        color: #ffffff;
        overflow-x: auto;
      }

      .header {
        background: linear-gradient(135deg, #1e293b, #334155);
        padding: 20px;
        border-bottom: 2px solid #ef4444;
        position: sticky;
        top: 0;
        z-index: 100;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .header h1 {
        color: #ef4444;
        font-size: 2rem;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .header-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 0.9rem;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 2s infinite;
      }

      .status-dot.online {
        background-color: #10b981;
      }
      .status-dot.offline {
        background-color: #ef4444;
      }
      .status-dot.warning {
        background-color: #f59e0b;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .system-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .metric-card {
        background: linear-gradient(135deg, #1e293b, #334155);
        border: 1px solid #475569;
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        transition: all 0.3s ease;
      }

      .metric-card:hover {
        border-color: #ef4444;
        box-shadow: 0 8px 25px rgba(239, 68, 68, 0.2);
      }

      .metric-value {
        font-size: 2rem;
        font-weight: bold;
        color: #ef4444;
        margin-bottom: 8px;
      }

      .metric-label {
        color: #94a3b8;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .cameras-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 25px;
      }

      .camera-card {
        background: linear-gradient(135deg, #1e293b, #334155);
        border: 1px solid #475569;
        border-radius: 16px;
        overflow: hidden;
        transition: all 0.3s ease;
        position: relative;
      }

      .camera-card:hover {
        border-color: #ef4444;
        box-shadow: 0 12px 30px rgba(239, 68, 68, 0.3);
        transform: translateY(-2px);
      }

      .camera-header {
        background: linear-gradient(90deg, #ef4444, #dc2626);
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .camera-id {
        font-size: 1.2rem;
        font-weight: bold;
        color: white;
      }

      .camera-status {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        font-size: 0.8rem;
      }

      .video-container {
        position: relative;
        aspect-ratio: 16/9;
        background-color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .video-player {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        color: white;
      }

      .video-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        color: #6b7280;
      }

      .video-placeholder svg {
        width: 64px;
        height: 64px;
      }

      .camera-info {
        padding: 20px;
      }

      .info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-bottom: 15px;
      }

      .info-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .info-label {
        color: #94a3b8;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .info-value {
        color: #ffffff;
        font-weight: 500;
      }

      .quality-badges {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .quality-badge {
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
      }

      .quality-badge.available {
        background-color: #10b981;
        color: white;
      }

      .quality-badge.unavailable {
        background-color: #6b7280;
        color: #d1d5db;
      }

      .camera-actions {
        display: flex;
        gap: 8px;
        margin-top: 15px;
      }

      .action-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 500;
        transition: all 0.2s ease;
        flex: 1;
      }

      .action-btn.restart {
        background-color: #f59e0b;
        color: white;
      }

      .action-btn.restart:hover {
        background-color: #d97706;
      }

      .action-btn.fullscreen {
        background-color: #3b82f6;
        color: white;
      }

      .action-btn.fullscreen:hover {
        background-color: #2563eb;
      }

      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        color: #6b7280;
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #374151;
        border-top: 2px solid #ef4444;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .error-message {
        background-color: #fee2e2;
        border: 1px solid #fca5a5;
        color: #dc2626;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        text-align: center;
      }

      .timestamp {
        color: #6b7280;
        font-size: 0.8rem;
        text-align: center;
        margin-top: 20px;
      }

      @media (max-width: 768px) {
        .cameras-grid {
          grid-template-columns: 1fr;
        }

        .system-metrics {
          grid-template-columns: repeat(2, 1fr);
        }

        .header h1 {
          font-size: 1.5rem;
        }

        .info-grid {
          grid-template-columns: 1fr;
        }
      }

      /* HLS.js specific styles */
      .hls-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .quality-selector {
        position: absolute;
        bottom: 60px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 6px;
        border-radius: 6px;
        z-index: 10;
        display: flex;
        gap: 8px;
      }

      .quality-btn {
        padding: 4px 8px;
        border: none;
        border-radius: 4px;
        background: transparent;
        color: #fff;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s;
      }

      .quality-btn.active {
        background-color: #ef4444;
      }

      .quality-btn:hover {
        background-color: rgba(239, 68, 68, 0.5);
      }

      .playback-controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        padding: 8px;
        border-radius: 6px;
        z-index: 10;
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .playback-btn {
        background: transparent;
        border: none;
        color: white;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s;
      }

      .playback-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .playback-btn svg {
        width: 24px;
        height: 24px;
      }

      .time-display {
        color: white;
        font-size: 0.8rem;
        min-width: 80px;
        text-align: center;
      }

      .progress-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background-color: rgba(255, 255, 255, 0.2);
        cursor: pointer;
      }

      .progress-bar-fill {
        height: 100%;
        background-color: #ef4444;
        width: 0%;
        transition: width 0.1s linear;
      }

      .history-panel {
        background: rgba(0, 0, 0, 0.8);
        position: absolute;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100%;
        transition: right 0.3s ease;
        z-index: 15;
        padding: 20px;
        color: white;
        overflow-y: auto;
      }

      .history-panel.open {
        right: 0;
      }

      .history-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        border: none;
        color: white;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        z-index: 11;
      }

      .history-toggle svg {
        width: 24px;
        height: 24px;
      }

      .date-selector {
        margin-bottom: 20px;
      }

      .date-selector select {
        width: 100%;
        padding: 8px;
        background: #1e293b;
        border: 1px solid #475569;
        color: white;
        border-radius: 4px;
        margin-top: 4px;
      }

      .hour-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .hour-btn {
        padding: 8px;
        background: #1e293b;
        border: 1px solid #475569;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s;
      }

      .hour-btn:hover {
        border-color: #ef4444;
      }

      .hour-btn.available {
        background: #374151;
      }

      .hour-btn.selected {
        background: #ef4444;
        border-color: #ef4444;
      }

      .no-recordings {
        text-align: center;
        color: #94a3b8;
        margin-top: 20px;
        font-size: 0.9rem;
      }

      .jump-to-live {
        background-color: #ef4444;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        display: none; /* Hidden by default */
        animation: pulse 2s infinite;
      }

      .jump-to-live.visible {
        display: block;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      .live-indicator {
        position: absolute;
        right: 12px;
        top: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 6px 12px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        z-index: 20;
        transition: all 0.3s ease;
      }

      .live-indicator.behind {
        opacity: 0.6;
      }

      .live-indicator:hover {
        background-color: #ef4444;
      }

      .live-dot {
        width: 8px;
        height: 8px;
        background-color: #ef4444;
        border-radius: 50%;
      }

      .live-indicator.behind .live-dot {
        background-color: #6b7280;
      }

      .live-text {
        color: white;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
      }

      .camera-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 10px;
        z-index: 20;
      }

      .control-btn {
        background: rgba(0, 0, 0, 0.8);
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: rgba(239, 68, 68, 0.9);
      }

      .history-btn {
        background: rgba(239, 68, 68, 0.8);
      }

      .action-btn.history {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
      }

      .action-btn.history:hover {
        background: linear-gradient(135deg, #2563eb, #1d4ed8);
      }

      .history-panel {
        background: rgba(17, 24, 39, 0.95);
        position: absolute;
        top: 0;
        right: -320px;
        width: 320px;
        height: 100%;
        transition: right 0.3s ease;
        z-index: 25;
        padding: 20px;
        color: white;
        overflow-y: auto;
        border-left: 2px solid #ef4444;
        box-shadow: -4px 0 15px rgba(0, 0, 0, 0.3);
      }

      .history-panel.open {
        right: 0;
      }

      .history-panel h3 {
        color: #ef4444;
        margin-bottom: 15px;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .hour-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 15px;
      }

      .hour-btn {
        padding: 8px;
        background: #1e293b;
        border: 1px solid #475569;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .hour-btn:hover:not(:disabled) {
        border-color: #ef4444;
        background: #2d3748;
      }

      .hour-btn.available {
        background: #374151;
        border-color: #ef4444;
      }

      .hour-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="header-info">
        <div>
          <h1>
            <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"
              />
            </svg>
            CCTV Monitoring Dashboard
          </h1>
          <div class="status-indicator">
            <div class="status-dot online" id="connectionStatus"></div>
            <span id="connectionText">Connected</span>
          </div>
        </div>
        <div class="header-status">
          <div class="status-indicator">
            <span>Last Update: <span id="lastUpdate">--:--:--</span></span>
          </div>
          <div class="status-indicator">
            <span>Active Cameras: <span id="activeCameraCount">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <!-- System Metrics -->
      <div class="system-metrics" id="systemMetrics">
        <div class="metric-card">
          <div class="metric-value" id="cpuUsage">--</div>
          <div class="metric-label">CPU Usage</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="memoryUsage">--</div>
          <div class="metric-label">Memory Usage</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="diskUsage">--</div>
          <div class="metric-label">Disk Usage</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="ffmpegProcesses">--</div>
          <div class="metric-label">FFmpeg Processes</div>
        </div>
      </div>

      <!-- Loading State -->
      <div id="loadingState" class="loading">
        <div class="spinner"></div>
        <span>Loading cameras...</span>
      </div>

      <!-- Error State -->
      <div id="errorState" class="error-message" style="display: none">
        <strong>Connection Error:</strong>
        <div id="errorMessage">Unable to connect to CCTV server</div>
        <button onclick="loadDashboard()" class="error-retry-btn">
          Retry Connection
        </button>
      </div>

      <!-- Cameras Grid -->
      <div class="cameras-grid" id="camerasGrid"></div>

      <div class="timestamp">Dashboard Auto-refreshes every 15 seconds</div>
    </div>

    <!-- HLS.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js.map"></script>

    <script>
      // Configuration
      const API_BASE_URL = window.location.origin;
      const REFRESH_INTERVAL = 15000; // 15 seconds
      const CAMERA_IDS = ["102"]; // Let's focus on the one camera we know exists

      // Add debug logging
      const DEBUG = true;
      function log(...args) {
        if (DEBUG) console.log("[CCTV Debug]", ...args);
      }

      let refreshTimer;
      let hlsPlayers = new Map();

      // Initialize dashboard
      document.addEventListener("DOMContentLoaded", function () {
        loadDashboard();
        startAutoRefresh();
      });

      // Auto-refresh functionality
      function startAutoRefresh() {
        if (refreshTimer) clearInterval(refreshTimer);
        refreshTimer = setInterval(() => {
          loadDashboard();
        }, REFRESH_INTERVAL);
      }

      // Main dashboard loading function
      async function loadDashboard() {
        updateLastUpdateTime();

        try {
          // Load system metrics and cameras in parallel
          const [systemData, camerasData] = await Promise.all([
            loadSystemMetrics(),
            loadCameras()
          ]);

          updateConnectionStatus(true);
          updateSystemMetrics(systemData);
          updateCamerasGrid(camerasData);
          hideError();
        } catch (error) {
          console.error("Dashboard load error:", error);
          updateConnectionStatus(false);
          showError(error.message);
        }
      }

      // Load system metrics
      async function loadSystemMetrics() {
        try {
          const response = await fetch(`${API_BASE_URL}/system/metrics`);
          if (!response.ok) throw new Error("System metrics unavailable");
          return await response.json();
        } catch (error) {
          // Return default values if system metrics endpoint doesn't exist
          return {
            cpu: { usage: 0 },
            memory: { usage: 0 },
            disk: { usage: 0 },
            processes: { ffmpeg: 0 }
          };
        }
      }

      // Load cameras data
      async function loadCameras() {
        const response = await fetch(`${API_BASE_URL}/streams/cameras`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        return data.cameras || [];
      }

      // Update system metrics display
      function updateSystemMetrics(data) {
        document.getElementById("cpuUsage").textContent = data.cpu
          ? `${Math.round(data.cpu.usage)}%`
          : "--";
        document.getElementById("memoryUsage").textContent = data.memory
          ? `${Math.round(data.memory.usage)}%`
          : "--";
        document.getElementById("diskUsage").textContent = data.disk
          ? `${Math.round(data.disk.usage)}%`
          : "--";
        document.getElementById("ffmpegProcesses").textContent = data.processes
          ? data.processes.ffmpeg
          : "--";
      }

      // Update cameras grid
      function updateCamerasGrid(cameras) {
        const grid = document.getElementById("camerasGrid");
        const loadingState = document.getElementById("loadingState");

        loadingState.style.display = "none";

        // Clear existing HLS players
        hlsPlayers.forEach((hls) => {
          if (hls) hls.destroy();
        });
        hlsPlayers.clear();

        // For testing, assume camera 102 is always active since we know it works
        const allCameras = CAMERA_IDS.map((id) => ({
          camera_id: id,
          status: {
            running: { high: true, low: true }, // Force camera to be considered active
            restartAttempts: 0,
            healthCheck: true
          }
        }));

        // Update active camera count
        document.getElementById("activeCameraCount").textContent =
          allCameras.length;

        // Generate camera cards
        grid.innerHTML = allCameras
          .map((camera) => createCameraCard(camera))
          .join("");

        // Initialize HLS players for all cameras
        allCameras.forEach((camera) => {
          initializeHLSPlayer(camera);
        });
      }

      // Create camera card HTML
      function createCameraCard(camera) {
        return `
          <div class="camera-card">
            <div class="camera-header">
              <div class="camera-id">Camera ${camera.camera_id}</div>
              <div class="camera-status">
                <div class="status-dot online"></div>
                Active
              </div>
            </div>
            
            <div class="video-container">
              <video id="video-${camera.camera_id}" class="video-player" 
                     muted autoplay playsinline controls>
              </video>
              <div class="video-overlay">LIVE</div>
              <div id="loading-${camera.camera_id}" class="hls-loading">
                <div class="spinner"></div>
              </div>
              
              <div class="live-indicator" id="live-${camera.camera_id}" onclick="jumpToLive('${camera.camera_id}')">
                <div class="live-dot"></div>
                <span class="live-text">LIVE</span>
              </div>

              <div id="history-${camera.camera_id}" class="history-panel">
                <h3>Recorded Footage</h3>
                <div class="date-selector">
                  <label>Select Date:</label>
                  <select id="date-select-${camera.camera_id}" onchange="loadHours('${camera.camera_id}')">
                    <option value="">Loading dates...</option>
                  </select>
                </div>
                <div class="hour-grid" id="hour-grid-${camera.camera_id}">
                  <!-- Hours will be populated dynamically -->
                </div>
                <div class="no-recordings" id="no-recordings-${camera.camera_id}" style="display: none;">
                  No recordings available for selected date
                </div>
              </div>

              <div class="camera-controls">
                <button class="control-btn history-btn" onclick="toggleHistory('${camera.camera_id}')" title="View Recordings">
                  <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8z"/>
                  </svg>
                  Recordings
                </button>
                <button class="control-btn fullscreen-btn" onclick="openFullscreen('video-${camera.camera_id}')" title="Fullscreen">
                  <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <div class="camera-info">
              <div class="info-grid">
                <div class="info-item">
                  <div class="info-label">Status</div>
                  <div class="info-value">Streaming</div>
                </div>
                <div class="info-item">
                  <div class="info-label">Quality</div>
                  <div class="info-value">
                    <div class="quality-badges">
                      <span class="quality-badge available" id="quality-${camera.camera_id}">480p</span>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="camera-actions">
                <button class="action-btn restart" onclick="restartCamera('${camera.camera_id}')">
                  Restart Camera
                </button>
                <button class="action-btn history" onclick="toggleHistory('${camera.camera_id}')">
                  <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16" style="margin-right: 8px;">
                    <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8z"/>
                  </svg>
                  View Recordings
                </button>
              </div>
            </div>
          </div>
        `;
      }

      // Initialize HLS player for a camera
      function initializeHLSPlayer(camera) {
        const videoElement = document.getElementById(
          `video-${camera.camera_id}`
        );
        const loadingElement = document.getElementById(
          `loading-${camera.camera_id}`
        );

        if (!videoElement || !Hls.isSupported()) {
          return;
        }

        videoElement.preload = "auto";
        const hls = new Hls(HLS_CONFIG);

        // Add live status checking with better time handling
        setInterval(() => {
          if (hls && videoElement && !videoElement.paused) {
            const liveEdge = hls.liveSyncPosition;
            const currentTime = videoElement.currentTime;
            const liveIndicator = document.getElementById(
              `live-${camera.camera_id}`
            );

            if (liveEdge && currentTime) {
              const behind = liveEdge - currentTime;
              if (behind > 10) {
                liveIndicator.classList.add("behind");
                // If we're way too far behind, force jump to live
                if (behind > 60) {
                  jumpToLive(camera.camera_id);
                }
              } else {
                liveIndicator.classList.remove("behind");
              }
            }
          }
        }, 1000);

        // Use the new live stream path
        const streamUrl = `${API_BASE_URL}/hls/${camera.camera_id}/live/live.m3u8`;
        hls.loadSource(streamUrl);
        hls.attachMedia(videoElement);

        // Store player reference
        hlsPlayers.set(camera.camera_id, hls);

        // Add specific handling for live streams
        hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {
          if (data.details.live) {
            // Force live mode settings
            hls.config.liveSyncDurationCount = 3;
            hls.config.liveMaxLatencyDurationCount = 6;

            // Try to start at live edge
            const seekTarget = hls.liveSyncPosition;
            if (seekTarget && !isNaN(seekTarget)) {
              videoElement.currentTime = seekTarget;
            }
          }
        });

        // Handle errors and recovery
        hls.on(Hls.Events.ERROR, function (event, data) {
          if (data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                console.log("Network error, trying to recover...");
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                console.log("Media error, trying to recover...");
                hls.recoverMediaError();
                break;
              default:
                console.log("Fatal error, reloading stream...");
                jumpToLive(camera.camera_id);
                break;
            }
          }
        });
      }

      // Utility functions
      function getUptime(camera) {
        if (!camera.last_seen) return "Unknown";
        const lastSeen = new Date(camera.last_seen);
        const now = new Date();
        const diffMs = now - lastSeen;
        const diffMins = Math.floor(diffMs / 60000);

        if (diffMins < 1) return "Just now";
        if (diffMins < 60) return `${diffMins}m ago`;
        const diffHours = Math.floor(diffMins / 60);
        if (diffHours < 24) return `${diffHours}h ${diffMins % 60}m`;
        const diffDays = Math.floor(diffHours / 24);
        return `${diffDays}d ${diffHours % 24}h`;
      }

      function updateConnectionStatus(connected) {
        const statusDot = document.getElementById("connectionStatus");
        const statusText = document.getElementById("connectionText");

        if (connected) {
          statusDot.className = "status-dot online";
          statusText.textContent = "Connected";
        } else {
          statusDot.className = "status-dot offline";
          statusText.textContent = "Disconnected";
        }
      }

      function updateLastUpdateTime() {
        const now = new Date();
        document.getElementById("lastUpdate").textContent =
          now.toLocaleTimeString("en-US", { hour12: false });
      }

      function showError(message) {
        document.getElementById("errorMessage").textContent = message;
        document.getElementById("errorState").style.display = "block";
        document.getElementById("loadingState").style.display = "none";
      }

      function hideError() {
        document.getElementById("errorState").style.display = "none";
      }

      // Camera actions
      async function restartCamera(cameraId) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/streams/restart/${cameraId}`,
            {
              method: "POST"
            }
          );

          if (response.ok) {
            const result = await response.json();
            if (result.success) {
              // Refresh dashboard after restart
              setTimeout(() => loadDashboard(), 3000);
            }
          }
        } catch (error) {
          console.error("Restart failed:", error);
        }
      }

      function openFullscreen(videoId) {
        const video = document.getElementById(videoId);
        if (video.requestFullscreen) {
          video.requestFullscreen();
        } else if (video.webkitRequestFullscreen) {
          video.webkitRequestFullscreen();
        } else if (video.msRequestFullscreen) {
          video.msRequestFullscreen();
        }
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        if (refreshTimer) clearInterval(refreshTimer);
        hlsPlayers.forEach((hls) => {
          if (hls) hls.destroy();
        });
      });

      // Quality switching function
      function switchQuality(cameraId, quality) {
        const videoElement = document.getElementById(`video-${cameraId}`);
        const qualityBtns =
          videoElement.parentElement.querySelectorAll(".quality-btn");
        const qualityBadge = document.getElementById(`quality-${cameraId}`);
        const currentTime = videoElement.currentTime;

        // Update UI
        qualityBtns.forEach((btn) => {
          btn.classList.remove("active");
          if (btn.textContent.toLowerCase().includes(quality)) {
            btn.classList.add("active");
          }
        });

        qualityBadge.textContent = quality === "high" ? "HD" : "480p";

        // Get new stream URL
        const streamUrl = `${API_BASE_URL}/hls/${cameraId}/live/${quality}.m3u8`;

        // Get HLS instance
        const hls = hlsPlayers.get(cameraId);
        if (hls) {
          hls.loadSource(streamUrl);
          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            videoElement.currentTime = currentTime;
            videoElement.play();
          });
        }
      }

      // Playback control functions
      function togglePlay(cameraId) {
        const video = document.getElementById(`video-${cameraId}`);
        const playBtn = document.getElementById(`play-${cameraId}`);

        if (video.paused) {
          video.play();
          playBtn.innerHTML =
            '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
        } else {
          video.pause();
          playBtn.innerHTML =
            '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
        }
      }

      function skipBackward(cameraId) {
        const video = document.getElementById(`video-${cameraId}`);
        video.currentTime = Math.max(0, video.currentTime - 10);
      }

      function skipForward(cameraId) {
        const video = document.getElementById(`video-${cameraId}`);
        video.currentTime = Math.min(video.duration, video.currentTime + 10);
      }

      function seek(event, cameraId) {
        const progressBar = document.getElementById(`progress-${cameraId}`);
        const video = document.getElementById(`video-${cameraId}`);
        const rect = progressBar.getBoundingClientRect();
        const pos = (event.clientX - rect.left) / rect.width;
        video.currentTime = pos * video.duration;
      }

      // Update time display and progress bar
      function updateVideoProgress(cameraId) {
        const video = document.getElementById(`video-${cameraId}`);
        const timeDisplay = document.getElementById(`time-${cameraId}`);
        const progressFill = document.getElementById(
          `progress-fill-${cameraId}`
        );

        if (video && timeDisplay && progressFill) {
          const current = formatTime(video.currentTime);
          const total = formatTime(video.duration);
          timeDisplay.textContent = `${current} / ${total}`;

          const progress = (video.currentTime / video.duration) * 100;
          progressFill.style.width = `${progress}%`;
        }
      }

      function formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return "00:00";
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, "0")}:${secs
          .toString()
          .padStart(2, "0")}`;
      }

      // Add video event listeners
      function addVideoEventListeners(cameraId) {
        const video = document.getElementById(`video-${cameraId}`);
        if (video) {
          video.addEventListener("timeupdate", () =>
            updateVideoProgress(cameraId)
          );
          video.addEventListener("play", () => {
            const playBtn = document.getElementById(`play-${cameraId}`);
            if (playBtn) {
              playBtn.innerHTML =
                '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
            }
          });
          video.addEventListener("pause", () => {
            const playBtn = document.getElementById(`play-${cameraId}`);
            if (playBtn) {
              playBtn.innerHTML =
                '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
            }
          });
        }
      }

      // Toggle history panel
      function toggleHistory(cameraId) {
        const panel = document.getElementById(`history-${cameraId}`);
        panel.classList.toggle("open");

        if (panel.classList.contains("open")) {
          loadDates(cameraId);
        }
      }

      // Load available dates for camera
      async function loadDates(cameraId) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/streams/playback/${cameraId}`
          );
          const data = await response.json();

          const select = document.getElementById(`date-select-${cameraId}`);
          if (data.available_dates && data.available_dates.length > 0) {
            select.innerHTML = data.available_dates
              .map(
                (date) => `<option value="${date}">${formatDate(date)}</option>`
              )
              .join("");

            // Load hours for first date
            loadHours(cameraId, data.available_dates[0]);
          } else {
            select.innerHTML =
              '<option value="">No recordings available</option>';
          }
        } catch (error) {
          console.error("Failed to load dates:", error);
        }
      }

      // Load available hours for selected date
      async function loadHours(cameraId, date) {
        const dateSelect = document.getElementById(`date-select-${cameraId}`);
        date = date || dateSelect.value;

        if (!date) return;

        try {
          const response = await fetch(
            `${API_BASE_URL}/streams/playback/${cameraId}?date=${date}`
          );
          const data = await response.json();

          const hourGrid = document.getElementById(`hour-grid-${cameraId}`);
          const noRecordings = document.getElementById(
            `no-recordings-${cameraId}`
          );

          if (data.available_hours && data.available_hours.length > 0) {
            hourGrid.innerHTML = generateHourButtons(
              cameraId,
              date,
              data.available_hours
            );
            hourGrid.style.display = "grid";
            noRecordings.style.display = "none";
          } else {
            hourGrid.style.display = "none";
            noRecordings.style.display = "block";
          }
        } catch (error) {
          console.error("Failed to load hours:", error);
        }
      }

      // Generate hour selection buttons
      function generateHourButtons(cameraId, date, availableHours) {
        const hours = [];
        for (let i = 0; i < 24; i++) {
          const hour = i.toString().padStart(2, "0");
          const isAvailable = availableHours.some((h) => h.startsWith(hour));
          hours.push(`
            <button class="hour-btn ${isAvailable ? "available" : ""}" 
                    onclick="playRecording('${cameraId}', '${date}', '${hour}')"
                    ${!isAvailable ? "disabled" : ""}>
              ${hour}:00
            </button>
          `);
        }
        return hours.join("");
      }

      // Update playback function for new recording structure
      async function playRecording(cameraId, date, hour) {
        try {
          const recordingUrl = `${API_BASE_URL}/hls/${cameraId}/recordings/${date}/${hour}/playlist.m3u8`;
          const videoElement = document.getElementById(`video-${cameraId}`);
          const hls = hlsPlayers.get(cameraId);

          // Update overlay to show recording status
          const overlay =
            videoElement.parentElement.querySelector(".video-overlay");
          overlay.textContent = `RECORDED: ${formatDate(date)} ${hour}:00`;
          overlay.style.backgroundColor = "#dc2626";

          if (hls) {
            hls.loadSource(recordingUrl);
            hls.on(Hls.Events.MANIFEST_PARSED, () => {
              videoElement.play();
            });
          }
        } catch (error) {
          console.error("Failed to play recording:", error);
        }
      }

      // Return to live stream
      function returnToLive(cameraId) {
        const streamUrl = `${API_BASE_URL}/hls/${cameraId}/live/live.m3u8`;
        const videoElement = document.getElementById(`video-${cameraId}`);
        const hls = hlsPlayers.get(cameraId);

        // Update overlay
        const overlay =
          videoElement.parentElement.querySelector(".video-overlay");
        overlay.textContent = "LIVE";
        overlay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";

        if (hls) {
          hls.loadSource(streamUrl);
          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            videoElement.play();
          });
        }
      }

      // Format date for display
      function formatDate(dateStr) {
        const date = new Date(dateStr);
        return date.toLocaleDateString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric"
        });
      }

      // Performance configuration
      const HLS_CONFIG = {
        maxBufferSize: 30 * 1000 * 1000, // 30MB max buffer
        maxBufferLength: 30, // 30 seconds max buffer
        maxMaxBufferLength: 60, // 60 seconds absolute max
        backBufferLength: 30, // Keep 30 seconds backward buffer for live
        enableWorker: true,
        lowLatencyMode: true,
        liveSyncDurationCount: 3, // Use 3 segments for stability
        liveMaxLatencyDurationCount: 6, // Reduced from 10 to 6
        liveDurationInfinity: false, // Don't allow infinite duration
        maxFragLookUpTolerance: 0.5,
        startLevel: -1, // Auto quality selection
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrBandWidthFactor: 0.9,
        abrBandWidthUpFactor: 0.7,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        fragLoadingTimeOut: 20000,
        manifestLoadingTimeOut: 20000,
        levelLoadingTimeOut: 20000,
        debug: false
      };

      // Track active players for cleanup
      const activePlayers = new Map();

      function initializePlayer(videoElement, streamUrl) {
        if (activePlayers.has(videoElement)) {
          const oldPlayer = activePlayers.get(videoElement);
          oldPlayer.destroy();
          activePlayers.delete(videoElement);
        }

        if (Hls.isSupported()) {
          const hls = new Hls(HLS_CONFIG);

          // Simpler latency monitoring
          let latencyHandler = setInterval(() => {
            if (hls && videoElement && !videoElement.paused) {
              if (hls.latency > 15) {
                // If latency exceeds 15 seconds
                videoElement.playbackRate = 1.25; // Speed up slightly
              } else {
                videoElement.playbackRate = 1.0; // Normal speed
              }
            }
          }, 2000);

          hls.loadSource(streamUrl);
          hls.attachMedia(videoElement);

          // Store player reference for cleanup
          activePlayers.set(videoElement, hls);

          hls.on(Hls.Events.MANIFEST_PARSED, function () {
            videoElement.play().catch(function (error) {
              console.log("Play failed:", error);
            });
          });

          // Error handling with recovery
          hls.on(Hls.Events.ERROR, function (event, data) {
            if (data.fatal) {
              switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  console.log("Network error, trying to recover...");
                  hls.startLoad();
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  console.log("Media error, trying to recover...");
                  hls.recoverMediaError();
                  break;
                default:
                  console.log("Fatal error, destroying player...");
                  clearInterval(latencyHandler);
                  hls.destroy();
                  break;
              }
            }
          });

          // Cleanup on destroy
          hls.on(Hls.Events.DESTROYING, function () {
            clearInterval(latencyHandler);
          });
        }
      }

      // Cleanup function for page unload
      window.addEventListener("beforeunload", function () {
        for (const [video, hls] of activePlayers) {
          hls.destroy();
        }
        activePlayers.clear();
      });

      // Visibility change handling
      document.addEventListener("visibilitychange", function () {
        if (document.hidden) {
          // Page is hidden, pause all streams
          for (const [video, hls] of activePlayers) {
            video.pause();
          }
        } else {
          // Page is visible again, resume streams
          for (const [video, hls] of activePlayers) {
            video.play().catch(console.log);
          }
        }
      });

      // Memory management
      setInterval(function () {
        if (window.performance && window.performance.memory) {
          const memory = window.performance.memory;
          if (memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.8) {
            console.log("High memory usage, cleaning up...");
            // Force garbage collection on players
            for (const [video, hls] of activePlayers) {
              hls.destroy();
              hls.attachMedia(video);
            }
          }
        }
      }, 30000);

      function jumpToLive(cameraId) {
        const hls = hlsPlayers.get(cameraId);
        const videoElement = document.getElementById(`video-${cameraId}`);
        const liveIndicator = document.getElementById(`live-${cameraId}`);

        if (hls && videoElement) {
          // Get the live edge position
          const livePosition = hls.liveSyncPosition;

          if (livePosition && !isNaN(livePosition)) {
            // Jump directly to live edge
            videoElement.currentTime = livePosition;
          } else {
            // If we can't get live position, reload the stream
            const streamUrl = `${API_BASE_URL}/hls/${cameraId}/live/live.m3u8`;
            hls.loadSource(streamUrl);
          }

          liveIndicator.classList.remove("behind");
          videoElement.play().catch(console.error);
        }
      }
    </script>
  </body>
</html>
